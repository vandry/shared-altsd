#!/bin/sh
#
# Renew the private key and certificate for shared-altsd as necessary
# and maintain the corresponding TLSA record in DNS. Intended to be
# run more or less daily from cron.

set -e
umask 077  # We are dealing with crypto keys.

### BEGIN configuration

# Directory where the keys and certificates are generated and kept.
# The user running this script should have write access to this
# directory. The user running shared-altsd itself should have read
# access. No other user should have access.
DIR=/usr/local/etc/alts

# Common name to generate in the certificate.
COMMON_NAME="$(hostname --fqdn)"

# Begin the renewal process when the active key is this many days from
# expiring.
RENEW_DAYS=10

# TTL to install on DNS record. Also, we wait at least this long after
# the DNS record is installed before rotating to a new certificate, so
# that, assuming the previous TLSA record had the same TTL, clients
# should be seeing the new one in DNS by the time it goes into use.
DNS_TTL=86400

# Function which should install or remove DNS RRs.
# Args: add|delete $TLSA_NAME $DNS_TTL rrdata
do_dns_update() {
    (
        echo "update $1 $2 $3 $4"
        echo send
    ) | nsupdate -k /a/b/c/Kdynamic-dns-update-key.generated-by-dnssec-keygen.key
}

# Do what is needed so that the shared-alts daemon will be able to read a file.
grant_to_altsd() {
    chgrp alts "$1"
    chmod g+r "$1"
}

### END configuration

cd "$DIR"

PAST_FILE=certificate_and_key.past.pem
PRESENT_FILE=certificate_and_key.pem
FUTURE_FILE=certificate_and_key.future.pem

# This is the DNS name that shared-altsd will query.
TLSA_NAME="_shared-alts.$COMMON_NAME"

# Args: File in PEM format containing certificate.
# Returns: TLSA RRdata
gen_tlsa() {
    # TLSA options:
    #   3 = DomainIssued: verify the certificate against this record alone.
    #   0 = hash the whole certificate (as opposed to only the public key).
    #   1 = Use SHA256
    # To use selector=1 instead (not tested):
    # openssl x509 -in "$FUTURE_FILE" -pubkey -noout |
    #     openssl rsa -pubin -outform der | sha256sum
    echo -n "3 0 1 "
    openssl x509 -in "$1" -outform DER | sha256sum | awk '{ print $1 }'
}

# Args: none
# Returns: TLSA records currently visible in DNS.
query_tlsa() {
    dig +short "$TLSA_NAME." tlsa |
            tr '[:upper:]' '[:lower:]' |
            # Remove spaces inside the large hex block
            sed -e 's/ /  /g' -e 's/^\([^ ]*\)  \([^ ]*\)  \([^ ]*\)  /\1 \2 \3 /' -e 's/  //g'
}

maybe_renew() {
    if [ -s "$PRESENT_FILE" ]; then
        if openssl x509 -checkend $((RENEW_DAYS * 86400)) \
                -noout -in "$PRESENT_FILE" >/dev/null; then
            return 0  # renewal not needed
        fi
    fi
    
    # Has the new key and cert been generated by a previous run?
    if [ ! -s "$FUTURE_FILE" ]; then
        # No? Generate it now...
        openssl req -x509 -newkey rsa:4096 \
            -keyout key.future.pem \
            -out certificate.future.pem \
            -subj "/CN=$COMMON_NAME" \
            -days 90 -nodes
        cat certificate.future.pem key.future.pem >"$FUTURE_FILE"
        rm -f certificate.future.pem key.future.pem
    fi
    
    # We use the timestamp of this file to know when a previous invocation of
    # this script installed the TLSA record corresponding to $FUTURE_FILE, so
    # that we do not rotate to using $FUTURE_FILE until at least a DNS TTL has
    # passed. To prevent a stray $MARKER_FILE that is not associated with
    # $FUTURE_FILE being used, we also require that the contents match
    # (otherwise we could just touch a 0-byte file).
    MARKER_FILE="$FUTURE_FILE.tlsa_installed"
    
    FUTURE_TLSA_RRDATA="$(gen_tlsa "$FUTURE_FILE")"
    
    if ! cmp -s "$FUTURE_FILE" "$MARKER_FILE"; then
        do_dns_update add "$TLSA_NAME." "$DNS_TTL" \
            "IN TLSA $FUTURE_TLSA_RRDATA"
        cp "$FUTURE_FILE" "$MARKER_FILE"
    
        # Now we need to wait for the TLSA record to appear in DNS.
        return 0
    fi
    
    TLSA_INSTALLED_AGE="$(expr $(date +%s) - $(stat -c %Y "$MARKER_FILE"))"
    if [ "$TLSA_INSTALLED_AGE" -lt "$DNS_TTL" ]; then
        # Need to wait longer
        return
    fi
    
    # Now that a TTL has elapsed, we should be able to see the new TLSA record
    # from here (or anywhere), but make sure.
    query_tlsa | fgrep -q "$FUTURE_TLSA_RRDATA" || {
        echo "TLSA record $FUTURE_TLSA_RRDATA not seen, so will not rotate certificate in." >&2
        return 1
    }
    
    grant_to_altsd "$FUTURE_FILE"

    # Deploy the new certificate

    if [ -e "$PRESENT_FILE" ]; then
        mv "$PRESENT_FILE" "$PAST_FILE"
    fi
    mv "$FUTURE_FILE" "$PRESENT_FILE"
    # Removing this file is not essential, but it is less confusing.
    rm -f "$MARKER_FILE"

    # TODO(vandry): Make the daemon reload.
}

maybe_expire_old_records() {
    set --
    for cert in "$PAST_FILE" "$PRESENT_FILE" "$FUTURE_FILE"; do
        if [ -s "$cert" ]; then
            set -- "$@" "$(gen_tlsa "$cert")"
        fi
    done
    query_tlsa | fgrep " " | while read result; do
        matches=false
        for exclude in "$@"; do
            if [ "x$result" = "x$exclude" ]; then
                matches=true
            fi
        done
        if [ false = "$matches" ]; then
            # This TLSA record matches against none of the certificates we know.
            do_dns_update delete "$TLSA_NAME." "$DNS_TTL" \
                "IN TLSA $result" || :
        fi
    done
}

EXIT_STATUS=0
if ! maybe_renew; then
    EXIT_STATUS=1
fi

maybe_expire_old_records

exit "$EXIT_STATUS"
